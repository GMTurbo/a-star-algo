var System = function(n) {
  function t(n, t) {
    var e = 10,
      i = Math.abs(n.x - t.x),
      a = Math.abs(n.y - t.y);
    return e * (i + a) + (1.41 * e - 2 * e) * function() {
      return i > a ? a : i
    }()
  }

  function e() {
    if (E) {
      if (P || 0 == q.length) return i(w), void(E = !1);
      w.open = 0;
      var n = _.min(q, function(n) {
        return n.F
      });
      if (w = n, q = _.reject(q, w), _.contains(C, w) || C.push(w), P = _.contains(C, b), !P) {
        var t = r(w, mesh);
        _.forEach(t, function(n) {
          a(w, n)
        })
      }
    }
  }

  function i(n) {
    n.finished = !0, n.parent && i(n.parent)
  }

  function a(n, e) {
    if (!e.wall && !_.contains(C, e)) {
      if (e.getIndex() == b.getIndex()) return b.parent = n, void(P = !0);
      var i = !1,
        a = o(n, e);
      _.contains(q, e) ? a < e.G && (i = !0) : (i = !0, e.parent = n, e.setHueristic(t(e, b)), e.open = 1, e.inPath = !0, q.push(e)), i && (e.parent = n, e.inPath = !0, e.setMovementCost(a)), e.inPath = !1
    }
  }

  function o(n, t) {
    return 1 == Math.abs(n.i - t.i) && 0 == Math.abs(n.j - t.j) ? 10 : 1 == Math.abs(n.j - t.j) && 0 == Math.abs(n.i - t.i) ? 10 : 1 == Math.abs(n.j - t.j) && 1 == Math.abs(n.i - t.i) ? 14 : 10
  }

  function r(n, t) {
    return _.filter(t, function(t) {
      return 1 == Math.abs(n.i - t.i) && 0 == Math.abs(n.j - t.j) ? !0 : 1 == Math.abs(n.j - t.j) && 0 == Math.abs(n.i - t.i) ? !0 : 1 == Math.abs(n.j - t.j) && 1 == Math.abs(n.i - t.i) ? !0 : !1
    })
  }

  function s() {
    y.clearRect(0, 0, p, g), _.forEach(mesh, function(n) {
      n.draw(y)
    })
  }

  function h() {
    e(), s(), j(h)
  }

  function u(n) {
    n.mouseDown1 ? d([n.x, n.y]) : n.mouseDown2 && l([n.x, n.y])
  }

  function c(n) {
    0 == n.keyCode || 32 == n.keyCode ? E = !E : 114 == n.keyCode ? F() : 99 == n.keyCode && _.forEach(mesh, function(n) {
      n.wall = !1
    })
  }

  function f(n) {
    return _.filter(mesh, function(t) {
      return Math.sqrt(Math.pow(n[0] - t.x, 2) + Math.pow(n[1] - t.y, 2)) < k
    })
  }

  function d(n) {
    nodes = f(n), nodes.length > 0 && _.forEach(nodes, function(n) {
      n.wall = !0
    })
  }

  function l(n) {
    nodes = f(n), nodes.length > 0 && _.forEach(nodes, function(n) {
      n.wall = !1
    })
  }

  function M(n) {
    p = n.width, g = n.height, F()
  }
  if (n = _.defaults(n, {
      density: .1,
      width: 100,
      height: 100,
      isMobile: !1
    }), !n.canvas) return void console.error("canvas element required for cops and robbas :/");
  if (!n.reqAnimationFrame) return void console.error("window.requestAnimationFrame required for cops and robbas :/");
  var m, b, w, v = n.canvas,
    p = n.width,
    g = n.height,
    j = (n.density, n.reqAnimationFrame),
    y = v.getContext("2d"),
    x = !0,
    q = (n.isMobile, []),
    C = [],
    E = !1,
    k = 15,
    F = function() {
      mesh = [], q = [], C = [], P = !1, E = !1, $(v).attr("width", p).attr("height", g);
      for (var n = 0, e = ~~(p / k); e > n; n++)
        for (var i = 0, a = ~~(g / k); a > i; i++) mesh.push(new Node({
          i: n,
          j: i,
          index: n * e + i,
          width: ~~k,
          wall: Math.random() <= .4
        }));
      m = mesh[0], m.startingNode = !0, w = m, b = mesh[~~(Math.random() * mesh.length - 1)], b.endingNode = !0, b.wall = !1, m.setHueristic(t(m, b)), q.push(w), x && (h(), x = !1)
    },
    P = !1;
  return {
    begin: F,
    resize: M,
    onMouseMove: u,
    onKeyPress: c
  }
};
